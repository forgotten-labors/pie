fs            = require "node-fs"
path          = require "path"
util          = require "util"
async         = require "async"
CoffeeScript  = require "coffee-script"
glob          = require "glob"
minimatch     = require "minimatch"
fsWatchTree   = require "fs-watch-tree"
nStore        = require "nstore"
growl         = require "growl"
compilers     = require "./compilers"
optparse      = require "./optparse"
_             = require "underscore"
_.mixin(require("underscore.string"))


_switches = []
_tasks = {}
_mappings = []
_db = null
_watches = {}


# the entry point (called from bin/pie)
exports.run = () ->
  load (err) ->
    return printErr(err) if err
    parser = new optparse.OptionParser(_switches)
    options = parser.parse(process.argv[2..])
    targets = options.arguments
    targets.push("list_tasks") if options.tasks
    targets.push("build") if targets.length == 0
    invoke targets, options, (err) ->
      if err
        growl("Piefile\n#{shortErr(err)}")
        printErr(err)

# bootstrap
load = (cb) ->
  option "-T", "--tasks", "List tasks"

  task "list_tasks", "Print out a list of tasks", (options, cb) ->
    _.each _.sortBy(_tasks, (t) -> t.name),
           (t) -> console.log _.sprintf("%-30s %s", "pie #{t.name}", t.desc)
    console.log ""
    _.each _.sortBy(_switches, (s) -> s[0]),
           (s) -> console.log _.sprintf("%-30s %s", "  #{s[0]}, #{s[1]}", s[2])
    console.log ""
    cb(null)

  # define a few default tasks
  task "build", "Build everything! (run all mappings, in the order defined)", runAllMappings

  task "clean", "Clean everything! (remove the files generated by the mappings)", cleanAllMappings

  task "watch", "Run a build, then start watching the filesystem for changes, triggering mappings as necessary", (options, cb) ->
    invoke "build", options, (err) ->
      return cb(err) if err
      startWatcher(options, cb)

  # slurp up the Piefile (can override the default tasks if it wants)
  evaluatePiefile (err) ->
    return cb(err) if err
    nStoreAlreadyFiredCallback = false
    _db = nStore.new(".pie.db", ((err) -> if !nStoreAlreadyFiredCallback then nStoreAlreadyFiredCallback = true; cb(err)))

evaluatePiefile = (cb) ->
  fs.readFile "Piefile", (err, code) ->
    return cb("No Piefile found. Please create one :)") if err && err.code == "ENOENT"
    return cb(err) if err
    try
      CoffeeScript.run(code.toString(), { filename: "Piefile" })
      cb(null)
    catch err
      growl("Piefile\n#{shortErr(err)}")
      printErr(err)

option = (args...) ->
  _switches.push(args)

task = (name, args...) ->
  _tasks[name] = new Task(name, args...)

invoke = (name, options, cb) ->
  if _.isArray(name)
    async.forEachSeries(name, ((name, innerCb) -> invoke(name, options, innerCb)), cb)
  else if t = _tasks[name]
    t.run(options, cb)
  else
    cb("No task named \"#{name}\" found")

map = (name, args...) ->
  m = new Mapping(name, args...)
  _mappings.push(m)
  task name, "Run #{name}", (options, cb) -> m.run(options, cb)

defineDefaultTasks = () ->

_.extend(global, { option: option, task: task, invoke: invoke, map: map, compilers: compilers })

getMtime = (file, cb) ->
  fs.stat file, (err, stats) ->
    return cb(err) if err
    cb(null, stats.mtime.getTime())

printErr = (err) ->
  if err
    if err.stack?
      console.log(err.stack)
    else
      console.log(shortErr(err))

shortErr = (err) ->
  if err.message?
    err.message
  else
    err.toString()

runAllMappings = (options, cb) ->
  async.forEachSeries _mappings, ((m, innerCb) -> m.run(options, innerCb)), (err) ->
    return cb(err) if err
    console.log "Build complete"
    growl "Build complete"
    cb(null)

cleanAllMappings = (options, cb) ->
  rm = (f, innerCb) ->
    try
      fs.unlink f, (err) ->
        console.log(f, err) if err && err.code != "ENOENT"
        innerCb(null)
    catch err
      console.log(f, err) if err && err.code != "ENOENT"
      innerCb(null)

  async.map _mappings, ((m, innerCb) -> m.outputFiles(innerCb)), (err, files) ->
    return cb(err) if err
    files.push ".pie.db"
    async.forEach _.uniq(_.flatten(files)), rm, cb

startWatcher = (options, cb) ->
  stopWatcher()

  # calculate watch targets
  toWatch = _.uniq(_.map(_.flatten(_.map(_mappings, (m) -> m.src)), (p) -> p.replace(/\*\*.*$/, '').replace(/\*\..+$/, '').replace(/\/$/, '')).sort())
  toWatch = _.filter(toWatch, (s) -> _.all(toWatch, (t) -> s == t or s.indexOf(t) != 0))

  startWatching = (path, innerCb) ->
    fs.stat path, (err, stats) ->
      return innerCb(err) if err
      if stats.isFile()
        console.log "Watching", path
        _watches[path] = fileWatcher(path, watchEvent)
      else if stats.isDirectory()
        console.log "Watching", path
        _watches[path] = fsWatchTree.watchTree(path, { exclude: [/\.pie\.db$/, /\.DS_Store$/, /^node_modules/, /^log/, /^tmp/, /~$/, /\#$/, /\.\#.+$/, /\.swp$/, /\.lock$/, /~\.nib$/] }, watchEvent)
      else
        innerCb("Don't know how to watch #{path}, as it isn't a file or a directory")

  console.log "Starting watcher"
  async.forEach(toWatch, startWatching, cb)

stopWatcher = () ->
  _.each _watches, (w, k) -> w.end()

watchEvent = (event) ->
  unless event.isDelete()
    console.log event.name, "changed"
    mappings = _.filter(_mappings, (m) -> m.matchesSrc(event.name))
    async.forEach mappings, ((m) -> m.runOnFiles([event.name], {}, printErr)), printErr

# watch a single file, but call handler with event like fs-watch-tree
fileWatcher = (path, handler) ->
  w = fs.watch path, (event) ->
    if event == "change"
      handler {
        isMkdir: () -> false
        isDelete: () -> false
        isModify: () -> true
        isDirectory: () -> false
        name: path
      }
  { end: () -> w.close() }

# just a lil' bit o' code
class Task
  constructor: (@name, @desc, @func) ->

  run: (options, cb) ->
    try
      @func(options, cb)
    catch err
      growl "#{@name}\n#{err}"
      cb(err)


# represents a mapping / build target
# stores mtimes of source files so it can be smart later. mtimes are stored scoped
# to each mapping, so that the same source files can be used in multiple mappings.
class Mapping
  constructor: (@name, @src, @dest, args...) ->
    if args.length == 1
      @func = args[0]
      @options = {}
    else if args.length == 2
      @func = args[1]
      @options = args[0]

  updateMtime: (file, cb) ->
    getMtime file, (err, mtime) =>
      return cb(err) if err
      _db.save("#{@name}:#{file}", mtime, cb)

  hasChanged: (file, cb) ->
    _db.get "#{@name}:#{file}", (err, prev) ->
      if !err && prev
        getMtime file, (err, mtime) ->
          return cb(err) if err
          cb(mtime != prev)
      else
        cb(true)

  findSrcFiles: (cb) ->
    if _.isString(@src)
      glob(@src, cb)
    else if _.isArray(@src)
      async.concat(@src, glob, cb)
    else
      cb("mapping src must be string or array of strings")

  calculateDest: (f) ->
    if _.isFunction(@dest)
      @dest(f)
    else
      @dest

  outputFiles: (cb) ->
    @findSrcFiles (err, files) =>
      return cb(err) if err
      cb(null, _.uniq(_.flatten(_.map(files, _.bind(@calculateDest, @)))))

  matchesSrc: (file) ->
    if _.isString(@src)
      minimatch(file, @src, {})
    else if _.isArray(@src)
      _.any @src, (s) -> minimatch(file, s, {})
    else
      throw "mapping src must be string or array of strings"

  run: (options, cb) ->
    @findSrcFiles (err, files) =>
      return cb(err) if err
      @runOnFiles(files, options, cb)

  runOnFiles: (files, options, cb) ->
    console.log "Running", @name, "on", files.length, "files"
    async.filter files, _.bind(@hasChanged, @), (changedFiles) =>
      unchangedFiles = _.without(files, changedFiles)

      if @options.batch
        if changedFiles.length > 0
          @execFunc changedFiles, options, (err) =>
            growl("#{@name}\n#{shortErr(err)}") if err
            return cb(err) if err
            async.forEach changedFiles, _.bind(@updateMtime, @), cb
        else
          cb(null)
      else
        if changedFiles.length > 0
          x = (f, innerCb) =>
            @execFunc f, options, (err) =>
              growl("#{f}\n#{shortErr(err)}") if err
              return innerCb(err) if err
              @updateMtime(f, innerCb)
          async.forEach changedFiles, x, cb
        else
          cb(null)

  execFunc: (f, options, cb) ->
    try
      @func(f, @calculateDest(f), options, cb)
    catch err
      cb(err)
